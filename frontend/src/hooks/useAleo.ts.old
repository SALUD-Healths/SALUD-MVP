/**
 * useAleo - React hook for Aleo blockchain interactions
 * 
 * Provides a clean interface for connecting wallets, executing transitions,
 * and managing transaction state in React components.
 */

import { useState, useCallback, useEffect, useRef } from 'react';
import { saludClient, SaludAleoClient } from '@/lib/aleo/client';
import { prepareRecordData, generateFieldNonce } from '@/lib/aleo/encryption';
import { DEFAULT_ACCESS_DURATION_BLOCKS, BLOCK_TIME_SECONDS } from '@/lib/aleo/config';
import { useUserStore, useRecordsStore } from '@/store';
import { useWallet } from '@demox-labs/aleo-wallet-adapter-react';
import type {
  AleoAccount,
  AleoMedicalRecord,
  TransactionStatus,
  CreateRecordInput,
  GrantAccessInput,
  VerifyAccessInput,
} from '@/lib/aleo/types';
import type { AccessGrant, RecordType } from '@/types/records';

// Transaction state for UI feedback
interface TransactionState {
  isProcessing: boolean;
  status: TransactionStatus | null;
  message: string | null;
  transactionId: string | null;
  error: string | null;
}

const initialTransactionState: TransactionState = {
  isProcessing: false,
  status: null,
  message: null,
  transactionId: null,
  error: null,
};

/**
 * Main Aleo hook for wallet and transaction management
 */
export function useAleo() {
  const [isConnecting, setIsConnecting] = useState(false);
  const [account, setAccount] = useState<AleoAccount | null>(null);
  const [blockHeight, setBlockHeight] = useState<number | null>(null);
  const [transaction, setTransaction] = useState<TransactionState>(initialTransactionState);
  
  const { connect: connectUser, disconnect: disconnectUser, setBalance } = useUserStore();
  const { addRecord, createAccessGrant, setLoading, setError } = useRecordsStore();
  
  // Get wallet adapter state (used for Leo Wallet viewing)
  const { connected: walletConnected, publicKey: walletPublicKey } = useWallet();
  
  // Keep track of polling interval
  const blockHeightInterval = useRef<ReturnType<typeof setInterval> | null>(null);

  /**
   * Connect wallet with private key
   */
  const connect = useCallback(async (privateKey: string): Promise<boolean> => {
    setIsConnecting(true);
    try {
      const connectedAccount = await saludClient.connect(privateKey);
      setAccount(connectedAccount);
      connectUser(connectedAccount.address, connectedAccount.viewKey);
      
      // Fetch initial balance
      const balance = await saludClient.getBalance();
      setBalance(balance);
      
      return true;
    } catch (error) {
      console.error('Failed to connect:', error);
      setError(error instanceof Error ? error.message : 'Failed to connect wallet');
      return false;
    } finally {
      setIsConnecting(false);
    }
  }, [connectUser, setBalance, setError]);

  /**
   * Disconnect wallet
   */
  const disconnect = useCallback(() => {
    saludClient.disconnect();
    setAccount(null);
    disconnectUser();
  }, [disconnectUser]);

  /**
   * Generate a new account
   */
  const generateAccount = useCallback(async (): Promise<AleoAccount> => {
    return SaludAleoClient.generateAccount();
  }, []);

  /**
   * Check if connected
   */
  const isConnected = useCallback((): boolean => {
    // Check multiple connection sources:
    // 1. SaludClient (private key connection)
    // 2. UserStore (app state)
    // 3. Wallet adapter (Leo Wallet)
    const userStore = useUserStore.getState();
    return saludClient.isConnected() || 
           (userStore.user?.isConnected ?? false) || 
           (walletConnected && walletPublicKey !== null);
  }, [walletConnected, walletPublicKey]);

  /**
   * Update transaction state helper
   */
  const updateTransactionStatus = useCallback((
    status: TransactionStatus,
    message?: string
  ) => {
    setTransaction((prev) => ({
      ...prev,
      status,
      message: message || null,
    }));
  }, []);

  /**
   * Create a new medical record
   */
  const createRecord = useCallback(async (
    title: string,
    description: string,
    recordType: RecordType,
    content: string,
    makeDiscoverable?: boolean
  ): Promise<boolean> => {
    if (!isConnected()) {
      setError('Please connect your wallet first');
      return false;
    }

    setTransaction({
      isProcessing: true,
      status: 'pending',
      message: 'Preparing record data...',
      transactionId: null,
      error: null,
    });
    setLoading(true);

    try {
      // Get the current account - requires private key connection
      const currentAccount = saludClient.getAccount();
      if (!currentAccount) {
        throw new Error('No account available for encryption. Please connect using "Import with Private Key".');
      }

      // Prepare encrypted data for on-chain storage
      const encryptionKey = currentAccount.privateKey;
      const nonce = generateFieldNonce();
      const { fields, dataHash, encryptedData } = await prepareRecordData(
        content,
        encryptionKey
      );

      const input: CreateRecordInput = {
        dataPart1: fields[0],
        dataPart2: fields[1],
        dataPart3: fields[2],
        dataPart4: fields[3],
        recordType,
        dataHash,
        nonce,
        makeDiscoverable: makeDiscoverable ?? true,
      };

      // Execute via saludClient
      const result = await saludClient.createRecord(input, updateTransactionStatus);

      if (!result.success || !result.data) {
        throw new Error(result.error || 'Failed to create record');
      }

      // Add to local store
      addRecord({
        recordId: result.data.record.record_id,
        title,
        description,
        recordType,
        data: JSON.stringify(encryptedData),
        dataHash,
        isEncrypted: true,
      });

      setTransaction({
        isProcessing: false,
        status: 'confirmed',
        message: 'Record created successfully!',
        transactionId: result.transactionId || null,
        error: null,
      });

      return true; // Success
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      setTransaction({
        isProcessing: false,
        status: 'failed',
        message: null,
        transactionId: null,
        error: errorMessage,
      });
      setError(errorMessage);
      return false;
    } finally {
      setLoading(false);
    }
  }, [account, isConnected, addRecord, setError, setLoading, updateTransactionStatus]);

  /**
   * Grant access to a doctor
   */
  const grantAccess = useCallback(async (
    medicalRecord: AleoMedicalRecord,
    doctorAddress: string,
    durationBlocks: number = DEFAULT_ACCESS_DURATION_BLOCKS
  ): Promise<AccessGrant | null> => {
    if (!isConnected() || !account) {
      setError('Please connect your wallet first');
      return null;
    }

    setTransaction({
      isProcessing: true,
      status: 'pending',
      message: 'Preparing access grant...',
      transactionId: null,
      error: null,
    });
    setLoading(true);

    try {
      const nonce = generateFieldNonce();

      const input: GrantAccessInput = {
        medicalRecord,
        doctorAddress,
        durationBlocks,
        nonce,
      };

      const result = await saludClient.grantAccess(input, updateTransactionStatus);

      if (!result.success || !result.data) {
        throw new Error(result.error || 'Failed to grant access');
      }

      // Calculate expiration time
      const expiresAt = new Date(Date.now() + durationBlocks * BLOCK_TIME_SECONDS * 1000);

      // Add to local store
      const localGrant = createAccessGrant({
        accessToken: result.data.accessToken,
        recordId: medicalRecord.record_id,
        patientAddress: account.address,
        doctorAddress,
        grantedAt: new Date(),
        expiresAt,
        durationBlocks,
        isRevoked: false,
      });

      setTransaction({
        isProcessing: false,
        status: 'confirmed',
        message: 'Access granted successfully!',
        transactionId: result.transactionId || null,
        error: null,
      });

      return localGrant;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      setTransaction({
        isProcessing: false,
        status: 'failed',
        message: null,
        transactionId: null,
        error: errorMessage,
      });
      setError(errorMessage);
      return null;
    } finally {
      setLoading(false);
    }
  }, [account, blockHeight, isConnected, createAccessGrant, setError, setLoading, updateTransactionStatus]);

  /**
   * Verify access (for doctors)
   */
  const verifyAccess = useCallback(async (
    accessToken: string,
    doctorAddress: string,
    recordId: string
  ): Promise<boolean> => {
    setTransaction({
      isProcessing: true,
      status: 'pending',
      message: 'Verifying access...',
      transactionId: null,
      error: null,
    });

    try {
      const input: VerifyAccessInput = {
        accessToken,
        doctorAddress,
        recordId,
      };

      const result = await saludClient.verifyAccess(input, updateTransactionStatus);

      const isValid = result.success && result.data?.isValid === true;

      setTransaction({
        isProcessing: false,
        status: isValid ? 'confirmed' : 'failed',
        message: isValid ? 'Access verified!' : 'Access denied or expired',
        transactionId: result.transactionId || null,
        error: isValid ? null : 'Access verification failed',
      });

      return isValid;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      setTransaction({
        isProcessing: false,
        status: 'failed',
        message: null,
        transactionId: null,
        error: errorMessage,
      });
      return false;
    }
  }, [updateTransactionStatus]);

  /**
   * Revoke access
   */
  const revokeAccess = useCallback(async (accessToken: string): Promise<boolean> => {
    if (!isConnected()) {
      setError('Please connect your wallet first');
      return false;
    }

    setTransaction({
      isProcessing: true,
      status: 'pending',
      message: 'Revoking access...',
      transactionId: null,
      error: null,
    });
    setLoading(true);

    try {
      const result = await saludClient.revokeAccess(
        { accessToken },
        updateTransactionStatus
      );

      if (!result.success) {
        throw new Error(result.error || 'Failed to revoke access');
      }

      // Update local store
      const { revokeAccessGrant } = useRecordsStore.getState();
      revokeAccessGrant(accessToken);

      setTransaction({
        isProcessing: false,
        status: 'confirmed',
        message: 'Access revoked successfully!',
        transactionId: result.transactionId || null,
        error: null,
      });

      return true;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      setTransaction({
        isProcessing: false,
        status: 'failed',
        message: null,
        transactionId: null,
        error: errorMessage,
      });
      setError(errorMessage);
      return false;
    } finally {
      setLoading(false);
    }
  }, [isConnected, setError, setLoading, updateTransactionStatus]);

  /**
   * Check if access token is valid (quick check via mapping)
   */
  const checkAccessTokenValid = useCallback(async (accessToken: string): Promise<boolean> => {
    try {
      return await saludClient.isAccessTokenValid(accessToken);
    } catch {
      return false;
    }
  }, []);

  /**
   * Get access grant details from chain
   */
  const getAccessGrantFromChain = useCallback(async (accessToken: string) => {
    try {
      return await saludClient.getAccessGrant(accessToken);
    } catch {
      return null;
    }
  }, []);

  /**
   * Refresh block height
   */
  const refreshBlockHeight = useCallback(async () => {
    try {
      const height = await saludClient.getCurrentBlockHeight();
      setBlockHeight(height);
      return height;
    } catch {
      return null;
    }
  }, []);

  /**
   * Clear transaction state
   */
  const clearTransaction = useCallback(() => {
    setTransaction(initialTransactionState);
  }, []);

  // Poll block height periodically when connected
  useEffect(() => {
    if (isConnected()) {
      // Initial fetch
      refreshBlockHeight();
      
      // Poll every 15 seconds (approximately 1 block time)
      blockHeightInterval.current = setInterval(refreshBlockHeight, 15000);
    }

    return () => {
      if (blockHeightInterval.current) {
        clearInterval(blockHeightInterval.current);
      }
    };
  }, [isConnected, refreshBlockHeight]);

  return {
    // Connection state
    isConnecting,
    isConnected: isConnected(),
    account,
    blockHeight,

    // Connection actions
    connect,
    disconnect,
    generateAccount,

    // Transaction actions
    createRecord,
    grantAccess,
    verifyAccess,
    revokeAccess,

    // Query actions
    checkAccessTokenValid,
    getAccessGrantFromChain,
    refreshBlockHeight,

    // Transaction state
    transaction,
    clearTransaction,
  };
}

/**
 * Simplified hook for just checking connection status
 */
export function useAleoConnection() {
  const { user } = useUserStore();
  
  return {
    isConnected: user?.isConnected ?? false,
    address: user?.address ?? null,
    balance: user?.balance ?? 0,
  };
}

/**
 * Hook for transaction status display
 */
export function useTransactionStatus() {
  const [status, setStatus] = useState<TransactionStatus | null>(null);
  const [message, setMessage] = useState<string | null>(null);

  const updateStatus = useCallback((newStatus: TransactionStatus, newMessage?: string) => {
    setStatus(newStatus);
    setMessage(newMessage ?? null);
  }, []);

  const clearStatus = useCallback(() => {
    setStatus(null);
    setMessage(null);
  }, []);

  return {
    status,
    message,
    updateStatus,
    clearStatus,
    isPending: status === 'pending',
    isConfirmed: status === 'confirmed',
    isFailed: status === 'failed',
  };
}

export type { AleoAccount, TransactionStatus };
